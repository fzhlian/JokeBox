"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HapProject = void 0;
const path = require("path");
const fs = require("fs");
const log4js = require("log4js");
const JSON5 = require("json5/lib/index");
const file_utils_1 = require("../utils/file_utils");
const logger = log4js.getLogger();
class HapProject {
    constructor(projectRoot) {
        this.projectRoot = projectRoot;
        this.deviceEntryMap = new Map();
        this.profileMap = new Map();
        this.mainAbilities = [];
        this.init();
    }
    getModule(deviceType) {
        return this.deviceEntryMap.get(deviceType);
    }
    isMainAbility(src) {
        return new Set(this.mainAbilities).has(src);
    }
    addInternetPermission() {
        this.profileMap.forEach((value, key) => {
            let hasPermission = this.isHasPermission(value);
            if (hasPermission) {
                return;
            }
            if (!value.config.module.requestPermissions) {
                value.config.module.requestPermissions = [];
            }
            value.config.module.requestPermissions.push({ name: 'ohos.permission.INTERNET' });
            fs.writeFileSync(key, JSON5.stringify(value.config, null, 4));
        });
    }
    isHasPermission(value) {
        let hasPermission = false;
        if (!value.config.module.requestPermissions) {
            return hasPermission;
        }
        for (const reqPem of value.config.module.requestPermissions) {
            if (reqPem.name === 'ohos.permission.INTERNET') {
                hasPermission = true;
                break;
            }
        }
        return hasPermission;
    }
    init() {
        let buildProfile = path.join(this.projectRoot, 'build-profile.json5');
        if (!fs.existsSync(buildProfile)) {
            logger.debug(`${buildProfile} is not exists.`);
            return;
        }
        for (const module of JSON5.parse(fs.readFileSync(buildProfile, { encoding: 'utf-8' })).modules) {
            let moduleProfile = path.join(this.projectRoot, module.srcPath, '/src/main/module.json5');
            if (!fs.existsSync(moduleProfile)) {
                logger.debug(`${moduleProfile} is not exists.`);
                return;
            }
            let config = JSON5.parse(fs.readFileSync(moduleProfile, { encoding: 'utf-8' }));
            this.profileMap.set(moduleProfile, { path: path.join(this.projectRoot, module.srcPath), profile: moduleProfile, config: config });
            if (!config.module.deviceTypes) {
                continue;
            }
            for (const deviceType of config.module.deviceTypes) {
                this.deviceEntryMap.set(deviceType, { path: path.join(this.projectRoot, module.srcPath), profile: moduleProfile, config: config });
            }
            if (config.module.abilities) {
                for (const ability of config.module.abilities) {
                    if (ability.srcEntry) {
                        this.mainAbilities.push((0, file_utils_1.relative)(this.projectRoot, path.join(this.projectRoot, module.srcPath, 'src', 'main', ability.srcEntry)));
                    }
                    else {
                        logger.debug('Cannot get ability entry');
                    }
                }
            }
            if (config.module.extensionAbilities) {
                for (const ability of config.module.extensionAbilities) {
                    if (ability.srcEntry) {
                        this.mainAbilities.push((0, file_utils_1.relative)(this.projectRoot, path.join(this.projectRoot, module.srcPath, 'src', 'main', ability.srcEntry)));
                    }
                    else if (ability.srcEntrance) {
                        this.mainAbilities.push((0, file_utils_1.relative)(this.projectRoot, path.join(this.projectRoot, module.srcPath, 'src', 'main', ability.srcEntrance)));
                    }
                    else {
                        logger.debug('Cannot get extensionability entry');
                    }
                }
            }
        }
    }
}
exports.HapProject = HapProject;
