"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bjcTransformer = void 0;
const globals_1 = require("../../plugin/globals");
const coverage_instrumenter_1 = require("./coverage_instrumenter");
const helper_1 = require("./helper");
const coverage_1 = require("../coverage");
function parseNamedImports(node) {
    var _a;
    let clauses = [];
    (_a = node.elements) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
        if (element.name && globals_1.Globals.tsc.isIdentifier(element.name)) {
            if (element.propertyName && globals_1.Globals.tsc.isIdentifier(element.propertyName)) {
                clauses.push(element.propertyName.text);
            }
            else {
                clauses.push(element.name.text);
            }
        }
    });
    return clauses;
}
function parseImportClause(node) {
    let clauses = [];
    if (node.importClause && node.importClause.name && globals_1.Globals.tsc.isIdentifier(node.importClause.name)) {
        clauses.push(node.importClause.name.text);
        return clauses;
    }
    if (!(node.importClause && node.importClause.namedBindings)) {
        return clauses;
    }
    if (globals_1.Globals.tsc.isNamedImports(node.importClause.namedBindings)) {
        return parseNamedImports(node.importClause.namedBindings);
    }
    if (globals_1.Globals.tsc.isNamespaceImport(node.importClause.namedBindings)) {
        if (node.importClause.namedBindings.name && globals_1.Globals.tsc.isIdentifier(node.importClause.namedBindings.name)) {
            clauses.push(node.importClause.namedBindings.name.text);
        }
    }
    return clauses;
}
function bjcTransformer(config, callback) {
    return (context) => {
        return (node) => {
            return internalTransformer(context, node, config, callback);
        };
    };
}
exports.bjcTransformer = bjcTransformer;
function ignoreConcurrentDec(node, sourceFile) {
    let funcNode = node;
    const printer = globals_1.Globals.tsc.createPrinter({ newLine: globals_1.Globals.tsc.NewLineKind.LineFeed });
    let funcText = printer.printNode(globals_1.Globals.tsc.EmitHint.Unspecified, funcNode, sourceFile);
    if (funcText.includes('use concurrent')) {
        helper_1.Helper.markNodeIgnored(funcNode, coverage_1.IgnoreType.Next, true);
    }
}
function ignoreSendableClass(node) {
    let clsNode = node;
    // @ts-expect-error
    if (node.original) {
        // @ts-expect-error
        node = node.original;
    }
    let decorators = globals_1.Globals.tsc.getDecorators(node) || [];
    if (decorators.length <= 0) {
        return;
    }
    decorators.map((v) => {
        if (globals_1.Globals.tsc.isIdentifier(v.expression) && v.expression.escapedText === 'Sendable') {
            helper_1.Helper.markNodeIgnored(clsNode, coverage_1.IgnoreType.Next, true);
        }
    });
}
function ignoreParamsLambda(node, sourceFile) {
    if (!sourceFile.text || sourceFile.text.indexOf('build()') === -1 || sourceFile.text.indexOf('struct') === -1) {
        return;
    }
    if (globals_1.Globals.tsc.isVariableDeclaration(node) && node.name && node.name.escapedText === 'paramsLambda') {
        helper_1.Helper.markNodeIgnored(node, coverage_1.IgnoreType.Next, true);
    }
}
function internalTransformer(context, node, config, callback) {
    const tsc = globals_1.Globals.tsc;
    let coverageMode = config.coverageMode;
    if (coverageMode !== 'black' && coverageMode !== 'white' && coverageMode !== 'full') {
        return node;
    }
    const projectPath = config.projectTopDir.replace(/\\/g, '/');
    let covInstrumenter = new coverage_instrumenter_1.CoverageInstrumenter(context, node, config, projectPath);
    let instrumenters = [covInstrumenter];
    let sourceFile = node;
    let importClause = [];
    let lineArr = [];
    function visitor(node) {
        if (tsc.isImportEqualsDeclaration(node)) {
            importClause.push(node.name.text);
        }
        else if (tsc.isImportDeclaration(node)) {
            importClause.push(...parseImportClause(node));
        }
        else if (tsc.isFunctionLike(node)) {
            ignoreConcurrentDec(node, sourceFile);
            for (const instrumenter of instrumenters) {
                node = instrumenter.visitFunctionNode(node);
            }
        }
        else if (tsc.isClassDeclaration(node)) {
            ignoreSendableClass(node);
            for (const instrumenter of instrumenters) {
                node = instrumenter.visitClassDeclarationNode(node);
            }
        }
        else {
            ignoreParamsLambda(node, sourceFile);
            if (node.pos >= 0) {
                let start = tsc.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));
                let line = start.line + 1;
                lineArr.push(line);
            }
        }
        return tsc.visitEachChild(node, visitor, context);
    }
    sourceFile = tsc.visitEachChild(node, visitor, context);
    lineArr = lineArr.sort((a, b) => a - b);
    const exeLine = Array.from(new Set(lineArr));
    covInstrumenter.setExeLine(exeLine);
    for (const instrumenter of instrumenters) {
        sourceFile = instrumenter.onDone(sourceFile, importClause);
    }
    if (callback) {
        const printer = tsc.createPrinter();
        callback(printer.printFile(sourceFile));
    }
    return sourceFile;
}
