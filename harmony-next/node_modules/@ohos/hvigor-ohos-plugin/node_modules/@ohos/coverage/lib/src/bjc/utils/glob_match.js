"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobMatch = void 0;
const Glob2Regex = new Map([
    ['*', '[^/]*'],
    ['?', '[^/]'],
    ['**', '(/.+?)?'],
]);
function replaceWildcardCharacter(match) {
    return match === '*' ? Glob2Regex.get('*') : match === '?' ? Glob2Regex.get('?') : '\\' + match;
}
class GlobMatch {
    constructor(include, exclude) {
        this.include = include;
        this.includeReg = new RegExp(this.include.map(this.transform).join('|'), 'i');
        this.exclude = exclude;
        this.excludeReg = new RegExp(this.exclude.map(this.transform).join('|'), 'i');
    }
    match(filePath) {
        if (this.exclude.length > 0) {
            return this.includeReg.test(filePath) && !this.excludeReg.test(filePath);
        }
        return this.includeReg.test(filePath);
    }
    transform(glob) {
        let regPattern = '';
        let segments = glob.split('/');
        let last = segments[segments.length - 1];
        // no extension add /**/* to end
        if (!/[.*?]/.test(last)) {
            segments.push('**', '*');
        }
        let hasWrittenSeg = false;
        for (let seg of segments) {
            if (seg === '**') {
                regPattern += Glob2Regex.get('**');
            }
            else {
                if (hasWrittenSeg) {
                    regPattern += '/';
                }
                regPattern += seg.replace(/[^\w\s\/]/g, replaceWildcardCharacter);
            }
            hasWrittenSeg = true;
        }
        return `^${regPattern}$`;
    }
}
exports.GlobMatch = GlobMatch;
