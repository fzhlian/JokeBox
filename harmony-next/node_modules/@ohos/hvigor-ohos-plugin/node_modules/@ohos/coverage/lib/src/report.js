"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeCoverageJson = exports.getjsCoverageData = exports.getInitCoverageData = exports.mergeCoverageData = exports.report = exports.targetKeyArr = void 0;
const fs = require("fs");
const path = require("path");
const fsExtra = require("fs-extra");
const log4js = require("log4js");
const os = require("os");
const bjc_1 = require("./bjc");
const buildInstrument_1 = require("./plugin/buildInstrument");
const standardErrorMessage_1 = require("./error/standardErrorMessage");
const logger = log4js.getLogger();
// 需要合并的覆盖率数据字段为 'count','trueCount','falseCount'
exports.targetKeyArr = ['count', 'trueCount', 'falseCount'];
/**
 * 功能：生成覆盖率报告
 * @param projectPath
 * @param reportPath 报告生成路径
 * @param coveragePath
 */
function report(projectPath, reportPath, coveragePath) {
    let bjcReport = new bjc_1.Report(coveragePath);
    const formattedProjectPath = projectPath.replace(/\\/g, '/');
    try {
        // 如果存在reports文件夹则删除
        if (fs.existsSync(reportPath)) {
            fsExtra.rmSync(reportPath, { recursive: true });
        }
        bjcReport.generateReport(formattedProjectPath);
        bjcReport.writeReport(formattedProjectPath, reportPath);
    }
    catch (err) {
        logger.error((0, standardErrorMessage_1.getFormattedErrorMsg)('REPORT_FAILED') + err);
    }
}
exports.report = report;
function setBase(base, key) {
    if (!base[key]) {
        base[key] = {};
    }
}
function mergeCoverageData(obj1, obj2, targetKeyArr) {
    const result = { ...obj1 }; // 从obj1开始，以确保其所有属性都被考虑 
    function mergeDeep(base, addition, targetkey, path = '') {
        let target = targetkey;
        for (const [key, value] of Object.entries(addition)) {
            const fullPath = path ? `${path}.${key}` : key;
            if (typeof value === 'object' && value !== null) {
                setBase(base, key);
                mergeDeep(base[key], value, target, fullPath);
            }
            else if (!(key in base) && targetKeyArr.includes(key)) {
                base[key] = 0;
            }
            else if (!(key in base)) {
                base[key] = value;
            }
            if (key === target) {
                base[key] = (base[key] || 0) + value;
            }
        }
    }
    for (let targetKey of targetKeyArr) {
        mergeDeep(result, obj2, targetKey, '');
    }
    return result;
}
exports.mergeCoverageData = mergeCoverageData;
/**
 * 功能：获得initCoverageData
 * @param coverageDataArrayPath
 * @returns initCoverageData 初始覆盖数据
 */
function getInitCoverageData(coverageDataArrayPath, projectPath) {
    let initCoverageData = {};
    try {
        let initCoveragePathArray = coverageDataArrayPath.filter((item) => item.indexOf('init_coverage.json') !== -1);
        if (initCoveragePathArray.length === 0) {
            throw new Error('the init_coverage.json file for the referenced module is missing in\'CoverageFile\'.');
        }
        coverageDataArrayPath.forEach((element) => {
            if (element.indexOf('init_coverage.json') === -1) {
                return;
            }
            let tmpInitCoverageData = fs.readFileSync(element, 'utf-8');
            if (!(0, buildInstrument_1.isSurroundedByCurlyBrace)(tmpInitCoverageData)) {
                tmpInitCoverageData = '{' + os.EOL + tmpInitCoverageData + '}' + os.EOL;
            }
            let jsonData = JSON.parse(tmpInitCoverageData);
            let formatCoverage = replaceProjectPath(jsonData, projectPath);
            initCoverageData = mergeCoverageData(initCoverageData, formatCoverage, exports.targetKeyArr);
        });
        return initCoverageData;
    }
    catch (err) {
        logger.error((0, standardErrorMessage_1.getFormattedErrorMsg)('GET_INIT_COVERAGE_DATA_FAILED'), err);
    }
    return initCoverageData;
}
exports.getInitCoverageData = getInitCoverageData;
/**
 * 获取执行插桩文件后的覆盖率数据
 * @param coverageDataArrayPath
 * @returns
 */
function getjsCoverageData(coverageDataArrayPath, projectPath) {
    let jsCoverageData = {};
    try {
        coverageDataArrayPath.forEach((element) => {
            if (element.indexOf('init_coverage.json') !== -1) {
                return;
            }
            let jsCoveragePath = element;
            if (fs.statSync(element).isDirectory()) {
                jsCoveragePath = (0, exports.mergeCoverageJson)(element);
            }
            let tmpJsCoverageData = JSON.parse(fs.readFileSync(jsCoveragePath, 'utf-8'));
            let formatCoverage = replaceProjectPath(tmpJsCoverageData, projectPath);
            jsCoverageData = mergeCoverageData(jsCoverageData, formatCoverage, exports.targetKeyArr);
        });
        return jsCoverageData;
    }
    catch (err) {
        logger.error((0, standardErrorMessage_1.getFormattedErrorMsg)('GET_JS_COVERAGE_DATA_FAILED'), err);
    }
    return jsCoverageData;
}
exports.getjsCoverageData = getjsCoverageData;
function replaceProjectPath(tmpCoverageData, projectPath) {
    let formatCoverage = {};
    for (const file of Object.values(tmpCoverageData)) {
        let fileData = file;
        if (!fileData.version) {
            continue;
        }
        fileData.path = fileData.path.replace(/\\/g, '/');
        if (fileData.projectPath) {
            let relativePath = path.relative(fileData.projectPath, fileData.path).replace(/\\/g, '/');
            fileData.path = path.resolve(projectPath, relativePath).replace(/\\/g, '/');
        }
        else {
            fileData.path = path.resolve(projectPath, fileData.path).replace(/\\/g, '/');
        }
        fileData.projectPath = projectPath;
        formatCoverage[fileData.path] = fileData;
    }
    return formatCoverage;
}
/**
 * 合并传入值为文件夹的覆盖率数据
 * @param coverageDir
 * @returns
 */
const mergeCoverageJson = (coverageDir) => {
    let allCoveragePath = path.join(coverageDir, 'allCoverage.json');
    try {
        if (fs.existsSync(allCoveragePath)) {
            fs.unlinkSync(allCoveragePath);
        }
        let coverageMap = {};
        const files = fs.readdirSync(coverageDir);
        files.forEach((file) => {
            const filePath = path.join(coverageDir, file);
            try {
                const coverageData = JSON.parse(fs.readFileSync(filePath).toString());
                coverageMap = mergeCoverageData(coverageMap, coverageData, exports.targetKeyArr);
            }
            catch (error) {
                logger.warn('exist invalid file or directory:', filePath);
            }
        });
        fs.writeFileSync(allCoveragePath, JSON.stringify(coverageMap));
    }
    catch (error) {
        logger.error((0, standardErrorMessage_1.getFormattedErrorMsg)('MERGE_COVERAGE_JSON_FAILED'), error);
    }
    return allCoveragePath;
};
exports.mergeCoverageJson = mergeCoverageJson;
