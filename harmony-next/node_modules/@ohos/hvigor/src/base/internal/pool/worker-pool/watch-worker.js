"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.normalWorker=exports.watchWorker=void 0;const cluster_1=__importDefault(require("cluster")),worker_threads_1=require("worker_threads"),hook_const_js_1=require("../../../../common/const/hook-const.js"),noop_js_1=require("../../../../common/util/noop.js"),build_event_js_1=require("../../../common/daemon-protocol/build-event.js"),worker_process_event_id_js_1=require("../../../daemon/cluster/worker-process-event-id.js"),hvigor_log_js_1=require("../../../log/hvigor-log.js"),duration_event_js_1=require("../../../metrics/event/duration-event.js"),log_event_js_1=require("../../../metrics/event/log-event.js"),hvigor_lifecycle_hook_js_1=require("../../lifecycle/hook/hvigor-lifecycle-hook.js"),constant_js_1=require("../constant/constant.js"),log=hvigor_log_js_1.HvigorLogger.getLogger("daemon");class WorkerItem{constructor(e,r){this.lastWatchResult={finish:!0,result:!0},this.resultResolveSet=new Set,this.worker=e,this.hasCustomTerminate=r,this.keepAlive=!1}}const genPromiseAndTriggers=(e,r)=>{let t=noop_js_1.noop,o=noop_js_1.noop;const s=new Promise((s,n)=>{t=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),n(t)},o=t=>{e.taskExecutedStatus.setWorkerTimePeriod([r,Number(process.hrtime.bigint())]),s(t)}});return{reject:t,resolve:o,promise:s}};async function handleResponse(e,r,t,o,s,n){if(e.event!==constant_js_1.PoolConstant.WORK_DONE){if(e.event===constant_js_1.PoolConstant.WORK_ERROR){null==n||n.stop(duration_event_js_1.DurationEventState.FAILED),null==n||n.setLog(null==n?void 0:n.getName(),log_event_js_1.MetricLogType.ERROR),await s(e.returnVal);const a=e.error,i=`${r.getName()} ${o?"watch":"normal"} work[${t}] failed.`;throw log.debug(i),new Error(a||i)}throw new Error(`Unknown worker event: ${e}.`)}null==n||n.stop(duration_event_js_1.DurationEventState.SUCCESS),null==n||n.setLog(null==n?void 0:n.getName(),log_event_js_1.MetricLogType.INFO),await s(e.returnVal)}class WorkerCountManager{static allocateWorkerId(){return this.cnt++}static reset(){this.cnt=1}}WorkerCountManager.cnt=1;class WatchWorker{constructor(){this.workerMap=new Map,this.addListenersOnSessionManager()}getWorker(e){var r;return null===(r=this.workerMap.get(e))||void 0===r?void 0:r.worker}async getLastWatchResult(e){const r=this.workerMap.get(e);return!r||(r.lastWatchResult.finish?r.lastWatchResult.result:new Promise(e=>{r.resultResolveSet.add(e)}))}sendCompileMsgToWorker(){this.workerMap.forEach((e,r)=>{e.worker.postMessage({event:"HOT_COMPILE"})})}sendNewWatchMsgToProcess(e){var r;cluster_1.default.isWorker&&process.send({type:build_event_js_1.WatchEvent.NEW_WATCH_WORKER,workerId:e}),null===(r=this.workerMap.get(e))||void 0===r||r.worker.postMessage({event:"PAUSE_PRINT_ERR",data:!1})}createWorker(e,r,t,o,s){const n=Number(process.hrtime.bigint()),a=new worker_threads_1.Worker(r,s),i=WorkerCountManager.allocateWorkerId();this.workerMap.set(i,new WorkerItem(a,t));const l=e.addSubDurationEvent(i.toString()).start();null==l||l.setTid(`Worker${i}`),this.sendNewWatchMsgToProcess(i);const{promise:c,resolve:_,reject:u}=genPromiseAndTriggers(e,n);return e.pendingPromises.add(c),this.createWorkerOnMessageListener(a,_,u,e,i,o,l),this.createWorkerOnErrorListener(a,u,e,i),i.toString()}createWorkerOnMessageListener(e,r,t,o,s,n,a){e.on("message",async e=>{if(e)if(e.event)try{await handleResponse(e,o,s,!0,n,a),r("succeed")}catch(e){t(e)}else{if(e.type===build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT||e.type===build_event_js_1.WatchEvent.WATCH_START||e.type===build_event_js_1.WatchEvent.WATCH_RESULT||e.type===build_event_js_1.WatchEvent.WATCH_LOG){log.debug(`watch worker: send response to session manager. Response type: ${e.type}`);try{await hvigor_lifecycle_hook_js_1.HvigorLifecycleHook.getInstance().runHook(hook_const_js_1.HookType.onWatchWorkerMessage,e,a)}catch(e){log.error(`custom onWatchWorkerMessage hook exception: ${e.message}`)}return this.forwardMessageToProcess(s,e),void this.handleWatchStartAndResult(s,e)}if(e.type===build_event_js_1.WatchEvent.TERMINATE_WORKER)return log.debug("watch worker: worker is ready to be terminated."),void this.terminateWorker(e.content);t(new Error(`Unknown watch event: ${e}.`))}else t(new Error("Undefined response."))})}forwardMessageToProcess(e,r){cluster_1.default.isWorker&&("hotCompile"===r.hotCompile?process.send({type:`${!0===r.content?worker_process_event_id_js_1.WORKER_PROCESS_EVENT_ID.FINISHED:worker_process_event_id_js_1.WORKER_PROCESS_EVENT_ID.FAILED}`}):process.send({...r,workerId:e}))}handleWatchStartAndResult(e,r){const t=this.workerMap.get(e);if(r.type===build_event_js_1.WatchEvent.WATCH_START&&t&&(t.lastWatchResult.finish=!1),r.type===build_event_js_1.WatchEvent.WATCH_RESULT&&t){for(const e of t.resultResolveSet)e(r.content);t.resultResolveSet.clear(),t.lastWatchResult={finish:!0,result:r.content}}}createWorkerOnErrorListener(e,r,t,o){e.on("error",async e=>{log.error(`${t.getName()} watch work[${o}] failed.`),log.error(e),r(e)})}terminate(e){var r,t;(null===(r=this.workerMap.get(e))||void 0===r?void 0:r.hasCustomTerminate)?null===(t=this.workerMap.get(e))||void 0===t||t.worker.postMessage({type:build_event_js_1.WatchEvent.TERMINATE_WORKER,content:e}):this.terminateWorker(e)}setAliveForWorker(e){const r=this.workerMap.get(e);r&&(r.keepAlive=!0)}consumeKeepAlive(e){const r=this.workerMap.get(e);return!!(null==r?void 0:r.keepAlive)&&(r.keepAlive=!1,!0)}terminateWorker(e){var r;null===(r=this.workerMap.get(e))||void 0===r||r.worker.terminate(),this.workerMap.delete(e),log.debug(`Server currently has ${this.workerMap.size} ${this.workerMap.size>1?"watch-workers":"watch-worker"}`)}addListenersOnSessionManager(){cluster_1.default.isWorker&&cluster_1.default.worker.on("message",e=>{var r,t,o,s;if(void 0!==e.workerId&&0!==e.workerId){if(e.type===build_event_js_1.WatchEvent.WATCH_COMPILE_DATA)log.debug("watch worker: receive watch compile tata."),null===(r=this.getWorker(e.workerId))||void 0===r||r.postMessage(e.content);else if(e.type===build_event_js_1.WatchEvent.SEND_KEEP_ALIVE_SIGNAL)this.setAliveForWorker(e.workerId);else if(e.type===build_event_js_1.WatchEvent.CLOSE_WATCH){if(this.consumeKeepAlive(e.workerId))return void(null===(s=null===(o=null===(t=this.workerMap.get(e.workerId))||void 0===t?void 0:t.worker)||void 0===o?void 0:o.postMessage)||void 0===s||s.call(o,{event:"PAUSE_PRINT_ERR",data:!0}));this.terminate(e.workerId)}}else log.debug("watch worker: worker id should be larger than 0. Nothing will be sent to any worker thread.")})}}class NormalWorker{constructor(){this.maxWorkerNum=constant_js_1.PoolConstant.MAX_POOL_NUM>1?constant_js_1.PoolConstant.MAX_POOL_NUM-1:1}createWorker(e,r,t,o,s){const n=Number(process.hrtime.bigint()),a=WorkerCountManager.allocateWorkerId(),{promise:i,resolve:l,reject:c}=genPromiseAndTriggers(e,n);return e.pendingPromises.add(i),NormalWorker.promiseMap.set(a,{resolve:l,reject:c}),NormalWorker.runningThreadCnt>=this.maxWorkerNum?(log.debug(`Creating worker failed since runningThreadCnt is not smaller than ${this.maxWorkerNum}.`),NormalWorker.workQueue.push({workerId:a,task:e,filename:r,callback:o,options:s})):(log.debug(`Creating worker with id ${a}.`),this.executeWorker(a,e,r,o,s)),a.toString()}reset(){NormalWorker.runningThreadCnt=0,NormalWorker.workQueue.length=0,NormalWorker.promiseMap.clear()}executeWorker(e,r,t,o,s){const n=new worker_threads_1.Worker(t,s);NormalWorker.runningThreadCnt++;const{resolve:a,reject:i}=NormalWorker.promiseMap.get(e);NormalWorker.promiseMap.delete(e);const l=r.addSubDurationEvent(e.toString()).start();null==l||l.setTid(`Worker${e}`),n.on("message",async t=>{if(t)if(t.event)try{await handleResponse(t,r,e,!1,o,l),n.terminate(),NormalWorker.runningThreadCnt--,this.processNextTask(),a(!0)}catch(e){i(e)}else t.type!==build_event_js_1.WatchEvent.WATCH_COMPILE_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_START&&t.type!==build_event_js_1.WatchEvent.WATCH_RESULT&&t.type!==build_event_js_1.WatchEvent.WATCH_LOG&&(t.type!==build_event_js_1.WatchEvent.TERMINATE_WORKER?i(new Error(`Unknown watch event: ${t}.`)):log.debug("Impossible response type in normal worker: TERMINATE_WORKER"));else i(new Error("Undefined response."))}),n.on("error",async t=>{log.debug(`${r.getName()} normal work[${e}] failed.`),i(t)})}processNextTask(){if(NormalWorker.workQueue.length){const e=NormalWorker.workQueue.shift();log.debug(`Normal worker queue is not empty. Create worker with id: ${e.workerId}.`),this.executeWorker(e.workerId,e.task,e.filename,e.callback,e.options)}}}NormalWorker.runningThreadCnt=0,NormalWorker.workQueue=[],NormalWorker.promiseMap=new Map,exports.watchWorker=new WatchWorker,exports.normalWorker=new NormalWorker;