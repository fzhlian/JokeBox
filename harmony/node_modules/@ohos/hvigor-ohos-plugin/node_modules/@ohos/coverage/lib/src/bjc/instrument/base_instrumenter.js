"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInstrumenter = exports.CoverageMode = void 0;
const path = require("path");
const file_utils_1 = require("../utils/file_utils");
const helper_1 = require("./helper");
const globals_1 = require("../../plugin/globals");
var CoverageMode;
(function (CoverageMode) {
    CoverageMode["BLACK"] = "black";
    CoverageMode["WHITE"] = "white";
    CoverageMode["FULL"] = "full";
})(CoverageMode = exports.CoverageMode || (exports.CoverageMode = {}));
;
class BaseInstrumenter {
    constructor(context, sourceFile, projectConfig) {
        this.context = context;
        this.sourceFile = sourceFile;
        this.projectConfig = projectConfig;
        this.anonymousCnt = 1;
        this.hasInstrument = false;
        this.relativePath = (0, file_utils_1.relative)(this.projectConfig.projectTopDir, this.sourceFile.fileName);
        this.tsc = globals_1.Globals.tsc;
    }
    buildMethodSignature(node) {
        let name = this.buildMethodName(node);
        let cls = this.buildBjcClass(node);
        if (cls.name.length > 0) {
            name = `${cls.name}.${name}`;
        }
        return name;
    }
    buildMethodName(node) {
        let name = '';
        if (this.tsc.isConstructorDeclaration(node)) {
            name = 'constructor';
        }
        else if (node.name === undefined) {
            name = `anonymous_${this.anonymousCnt++}`;
        }
        else if (this.tsc.isIdentifier(node.name)) {
            name = node.name.text;
        }
        return name;
    }
    buildBjcClass(node) {
        if (node.parent && this.tsc.isClassDeclaration(node.parent)) {
            return helper_1.Helper.parseClassDeclaration(node.parent);
        }
        return {
            name: '',
            extends: [],
            implements: [],
        };
    }
    getSourceFileName() {
        return path.basename(this.sourceFile.fileName);
    }
}
exports.BaseInstrumenter = BaseInstrumenter;
