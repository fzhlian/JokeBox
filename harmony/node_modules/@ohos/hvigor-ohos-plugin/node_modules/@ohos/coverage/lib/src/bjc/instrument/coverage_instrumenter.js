"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoverageInstrumenter = void 0;
const ts = require("typescript");
const fs = require("fs");
const path = require("path");
const os = require("os");
const helper_1 = require("./helper");
const coverage_1 = require("../coverage");
const base_instrumenter_1 = require("./base_instrumenter");
const hap_project_1 = require("./hap_project");
const constants_1 = require("../utils/constants");
const globals_1 = require("../../plugin/globals");
class InstrumenterFunction extends coverage_1.Function {
    constructor(name, index, ignored) {
        super(name, ignored);
        this.index = index;
    }
    addRegion(region) {
        this.regions.push(region);
        return this.regions.length - 1;
    }
    addBranch(branch) {
        this.branches.push(branch);
        return this.branches.length - 1;
    }
    /**
     * call objName.instrumentFunction(this.index)
     * @param objName
     * @returns
     */
    createFunctionInstrumentExpression(objName) {
        let stmt = globals_1.Globals.tsc.factory.createExpressionStatement(globals_1.Globals.tsc.factory.createCallExpression(globals_1.Globals.tsc.factory.createPropertyAccessExpression(globals_1.Globals.tsc.factory.createIdentifier(objName), globals_1.Globals.tsc.factory.createIdentifier('instrumentFunction')), undefined, [globals_1.Globals.tsc.factory.createNumericLiteral(this.index)]));
        return stmt;
    }
    /**
     * call objName.instrumentRegion(this.index, regionIdx)
     * @param objName
     * @param RegionIdx
     * @returns
     */
    createRegionInstrumentExpression(objName, regionIdx) {
        let stmt = globals_1.Globals.tsc.factory.createExpressionStatement(globals_1.Globals.tsc.factory.createCallExpression(globals_1.Globals.tsc.factory.createPropertyAccessExpression(globals_1.Globals.tsc.factory.createIdentifier(objName), globals_1.Globals.tsc.factory.createIdentifier('instrumentRegion')), undefined, [globals_1.Globals.tsc.factory.createNumericLiteral(this.index), globals_1.Globals.tsc.factory.createNumericLiteral(regionIdx)]));
        return stmt;
    }
    /**
     * call objName.instrumentReturn(this.index, retIdx)
     * @param objName
     * @param RegionIdx
     * @returns
     */
    createReturnInstrumentExpression(objName, retIdx) {
        let stmt = globals_1.Globals.tsc.factory.createExpressionStatement(globals_1.Globals.tsc.factory.createCallExpression(globals_1.Globals.tsc.factory.createPropertyAccessExpression(globals_1.Globals.tsc.factory.createIdentifier(objName), globals_1.Globals.tsc.factory.createIdentifier('instrumentReturn')), undefined, [globals_1.Globals.tsc.factory.createNumericLiteral(this.index), globals_1.Globals.tsc.factory.createNumericLiteral(retIdx)]));
        return stmt;
    }
    /**
     * call objName.instrumentRegion(this.index, RegionIdx, trueOrFalse)
     * @param objName
     * @param regionIdx
     * @param trueOrFalse
     * @returns
     */
    createBranchInstrumentExpression(objName, regionIdx, trueOrFalse) {
        let stmt = globals_1.Globals.tsc.factory.createExpressionStatement(globals_1.Globals.tsc.factory.createCallExpression(globals_1.Globals.tsc.factory.createPropertyAccessExpression(globals_1.Globals.tsc.factory.createIdentifier(objName), globals_1.Globals.tsc.factory.createIdentifier('instrumentBranch')), undefined, [
            globals_1.Globals.tsc.factory.createNumericLiteral(this.index),
            globals_1.Globals.tsc.factory.createNumericLiteral(regionIdx),
            trueOrFalse ? globals_1.Globals.tsc.factory.createTrue() : globals_1.Globals.tsc.factory.createFalse(),
        ]));
        return stmt;
    }
}
class CoverageInstrumenter extends base_instrumenter_1.BaseInstrumenter {
    constructor(context, sourceFile, projectConfig, projectPath) {
        super(context, sourceFile, projectConfig);
        this.coverageData = {
            version: 'bjc v1.0.0',
            versionCode: 10000,
            path: '',
            hash: '',
            lineCnt: 0,
            count: 0,
            projectPath: '',
            functions: new Array(),
            exeLine: []
        };
        this.hash = helper_1.Helper.hashNodeContent(sourceFile);
        this.coverageData.path = sourceFile.fileName;
        this.coverageData.hash = this.hash;
        this.coverageData.lineCnt = sourceFile.getLineAndCharacterOfPosition(sourceFile.end).line + 1;
        const formattedProjectPath = projectPath.replace(/\\/g, '/');
        this.coverageData.projectPath = formattedProjectPath;
        this.objName = `BjcCov${new Date().getTime().toString(36)}`.toLowerCase();
        this.anonymousCnt = 0;
        this.project = new hap_project_1.HapProject(projectConfig.projectTopDir);
        this.hasInstrumentCollector = false;
        this.hasInstrumentImportWant = false;
        this.markTargetNodesIgnored(sourceFile);
    }
    markTargetNodesIgnored(node) {
        let sourceFile = node;
        let visitor = (node) => {
            if (node.ignored === coverage_1.IgnoreType.Next) {
                return node;
            }
            if (node.ignored === undefined) {
                node.ignored = coverage_1.IgnoreType.None;
            }
            const ignoreType = helper_1.Helper.shouldIgnoreNode(node, this.sourceFile);
            if (ignoreType === coverage_1.IgnoreType.File) {
                helper_1.Helper.markNodeIgnored(sourceFile, coverage_1.IgnoreType.Next);
            }
            else if (ignoreType === coverage_1.IgnoreType.Next) {
                if (node !== sourceFile) {
                    helper_1.Helper.markNodeIgnored(node, ignoreType);
                }
            }
            else if (ignoreType === coverage_1.IgnoreType.If) {
                if (this.tsc.isIfStatement(node)) {
                    helper_1.Helper.markNodeIgnored(node.expression, coverage_1.IgnoreType.If);
                    helper_1.Helper.markNodeIgnored(node.thenStatement, coverage_1.IgnoreType.Next);
                }
            }
            else if (ignoreType === coverage_1.IgnoreType.Else) {
                if (this.tsc.isIfStatement(node) && node.elseStatement) {
                    helper_1.Helper.markNodeIgnored(node.expression, coverage_1.IgnoreType.Else);
                    helper_1.Helper.markNodeIgnored(node.elseStatement, coverage_1.IgnoreType.Next);
                }
            }
            return this.tsc.visitEachChild(node, visitor, this.context);
        };
        this.tsc.visitNode(node, visitor);
    }
    setExeLine(exeLine) {
        this.coverageData.exeLine = exeLine;
    }
    onDone(sourceFile) {
        return this.instrumentCoverageData(sourceFile);
    }
    visitClassDeclarationNode(node) {
        if (!this.tsc.isClassDeclaration(node) || !node.heritageClauses || !this.project.isMainAbility(this.relativePath)) {
            return node;
        }
        // extends UIAbility or AbilityStage instrument collector.
        if (this.projectConfig.coverageMode === base_instrumenter_1.CoverageMode.WHITE) {
            return node;
        }
        for (let extendCls of node.heritageClauses) {
            for (let type of extendCls.types) {
                if (this.tsc.isIdentifier(type.expression)) {
                    return this.instrumentAbilityCovCollector(node);
                }
            }
        }
        return node;
    }
    /**
     * get coverage data
     * @returns coverageData
     */
    getCoverageData() {
        return this.coverageData;
    }
    /**
     * Parse the function name and control flow to implement instrumentation
     * @param funcNode
     */
    visitFunctionNode(funcNode) {
        const parent = funcNode.parent;
        let func = this.getInstrumentFunction(funcNode);
        if (!func) {
            return funcNode;
        }
        funcNode = this.instrumentFunctionEntry(func, funcNode);
        let visitor = (node) => {
            if (this.tsc.isIfStatement(node)) {
                node = this.instrumentIf(func, node);
            }
            else if (this.tsc.isSwitchStatement(node)) {
                node = this.instrumentSwitch(func, node);
            }
            else if (this.tsc.isWhileStatement(node) ||
                this.tsc.isForStatement(node) ||
                this.tsc.isForInStatement(node) ||
                this.tsc.isForOfStatement(node) ||
                this.tsc.isDoStatement(node)) {
                node = this.instrumentLoop(func, node);
            }
            else if (this.tsc.isConditionalExpression(node)) {
                node = this.instrumentConditionalExpression(func, node);
            }
            else if (this.tsc.isTryStatement(node)) {
                node = this.instrumentTryStatement(func, node);
            }
            else if (this.tsc.isFunctionLike(node)) {
                return node;
            }
            return this.tsc.visitEachChild(node, visitor, this.context);
        };
        funcNode = this.tsc.visitEachChild(funcNode, visitor, this.context);
        let blockVisitor = (node) => {
            if (this.tsc.isBlock(node)) {
                node = this.instrumentBlock(func, node);
            }
            return this.tsc.visitEachChild(node, blockVisitor, this.context);
        };
        funcNode = this.tsc.visitEachChild(funcNode, blockVisitor, this.context);
        funcNode.parent = parent;
        return funcNode;
    }
    getInstrumentFunction(funcNode) {
        if (funcNode.ignored === coverage_1.IgnoreType.Next) {
            return undefined;
        }
        let func = this.parseFunction(funcNode);
        if (!func) {
            return undefined;
        }
        if (funcNode.body && this.tsc.isBlock(funcNode.body)) {
            if (this.isInstrumentFunctionStmt(funcNode.body.statements[0])) {
                return undefined;
            }
        }
        return func;
    }
    isInstrumentRegionStmt(stmt) {
        return this.isInstrumentStmt(stmt, 'instrumentRegion');
    }
    isInstrumentFunctionStmt(stmt) {
        return this.isInstrumentStmt(stmt, 'instrumentFunction');
    }
    isInstrumentStmt(stmt, type) {
        if (!stmt) {
            return false;
        }
        if (!this.tsc.isExpressionStatement(stmt)) {
            return false;
        }
        if (!this.tsc.isCallExpression(stmt.expression)) {
            return false;
        }
        if (!this.tsc.isPropertyAccessExpression(stmt.expression.expression)) {
            return false;
        }
        if (stmt.expression.expression.name.escapedText === type) {
            return true;
        }
        return false;
    }
    isControlStmt(node) {
        if (this.tsc.isIfStatement(node) ||
            this.tsc.isSwitchStatement(node) ||
            this.tsc.isWhileStatement(node) ||
            this.tsc.isForStatement(node) ||
            this.tsc.isForInStatement(node) ||
            this.tsc.isForOfStatement(node) ||
            this.tsc.isDoStatement(node) ||
            this.tsc.isTryStatement(node)) {
            return true;
        }
        return false;
    }
    instrumentBlock(func, node) {
        if (node.statements.length === 0) {
            return node;
        }
        let nodeIdx = 0;
        for (let idx = node.statements.length - 1; idx >= 0; idx--) {
            if (node.statements[idx].pos === -1 || this.isControlStmt(node.statements[idx])) {
                nodeIdx = idx;
                break;
            }
        }
        if (this.isInstrumentRegionStmt(node.statements[nodeIdx]) || nodeIdx === node.statements.length - 1) {
            return node;
        }
        let next = this.tsc.factory.createBlock([], true);
        next.pos = node.statements[nodeIdx + 1].pos;
        next.end = node.end;
        let region = this.getSourceRegion(next);
        if (!region) {
            return node;
        }
        let regionIdx = func.addRegion(region);
        let stmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
        let statements = Array.from(node.statements);
        statements.splice(nodeIdx + 1, 0, stmt);
        return this.tsc.factory.updateBlock(node, statements);
    }
    instrumentIf(func, node) {
        let thenStatement = node.thenStatement;
        let elseStatement = node.elseStatement;
        // then region
        let regionThen = this.getSourceRegion(node.thenStatement);
        let thenRegionStatement = undefined;
        if (regionThen) {
            thenRegionStatement = func.createRegionInstrumentExpression(this.objName, func.addRegion(regionThen));
        }
        // else region
        let regionElse = this.getSourceRegion(node.elseStatement);
        let elseRegionStatement = undefined;
        if (regionElse) {
            elseRegionStatement = func.createRegionInstrumentExpression(this.objName, func.addRegion(regionElse));
        }
        // expression branch
        let regionExpr = this.getSourceRegion(node.expression);
        let trueStatement = undefined;
        let falseStatement = undefined;
        if (regionExpr) {
            let branchIdx = func.addBranch(new coverage_1.Branch(regionExpr.startLoc, regionExpr.endLoc, node.expression.ignored));
            trueStatement = func.createBranchInstrumentExpression(this.objName, branchIdx, true);
            falseStatement = func.createBranchInstrumentExpression(this.objName, branchIdx, false);
        }
        thenStatement = this.transformThenStatement(node, thenRegionStatement, trueStatement, thenStatement);
        if (!node.elseStatement) {
            const statements = [];
            if (elseRegionStatement) {
                statements.unshift(elseRegionStatement);
            }
            if (falseStatement) {
                statements.unshift(falseStatement);
            }
            elseStatement = this.tsc.factory.createBlock(statements, true);
        }
        else {
            if (this.tsc.isBlock(node.elseStatement)) {
                const statements = Array.from(node.elseStatement.statements);
                if (elseRegionStatement) {
                    statements.unshift(elseRegionStatement);
                }
                if (falseStatement) {
                    statements.unshift(falseStatement);
                }
                elseStatement = this.tsc.factory.updateBlock(node.elseStatement, statements);
            }
            else {
                const statements = [node.elseStatement];
                if (elseRegionStatement) {
                    statements.unshift(elseRegionStatement);
                }
                if (falseStatement) {
                    statements.unshift(falseStatement);
                }
                elseStatement = this.tsc.factory.createBlock(statements, true);
            }
        }
        return this.tsc.factory.updateIfStatement(node, node.expression, thenStatement, elseStatement);
    }
    transformThenStatement(node, thenRegionStatement, trueStatement, thenStatement) {
        if (this.tsc.isBlock(node.thenStatement)) {
            const statements = Array.from(node.thenStatement.statements);
            if (thenRegionStatement) {
                statements.unshift(thenRegionStatement);
            }
            if (trueStatement) {
                statements.unshift(trueStatement);
            }
            thenStatement = this.tsc.factory.updateBlock(node.thenStatement, statements);
        }
        else {
            const statements = [node.thenStatement];
            if (thenRegionStatement) {
                statements.unshift(thenRegionStatement);
            }
            if (trueStatement) {
                statements.unshift(trueStatement);
            }
            thenStatement = this.tsc.factory.createBlock(statements, true);
        }
        return thenStatement;
    }
    instrumentSwitch(func, node) {
        let group = [];
        let clauses = [];
        for (let clause2 of node.caseBlock.clauses) {
            let clause = clause2;
            // instrument region
            let region = this.getSourceRegion(clause);
            if (!region) {
                continue;
            }
            let regionIdx = func.addRegion(region);
            let regionStmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
            // instrument branch
            let conditionRegion;
            if (this.tsc.isCaseClause(clause)) {
                conditionRegion = this.getSourceRegion(clause.original ? clause.original.expression : clause.expression);
            }
            else {
                conditionRegion = new coverage_1.Region(region.startLoc, region.startLoc, clause.ignored);
            }
            if (!conditionRegion) {
                continue;
            }
            let branchIdx = func.addBranch(new coverage_1.Branch(conditionRegion.startLoc, conditionRegion.endLoc, clause.ignored));
            func.branches[branchIdx].group = group;
            group.push(branchIdx);
            let branchStmt = func.createBranchInstrumentExpression(this.objName, branchIdx, true);
            const statements = Array.from(clause.statements);
            statements.unshift(regionStmt);
            statements.unshift(branchStmt);
            if (this.tsc.isCaseClause(clause)) {
                clauses.push(this.tsc.factory.updateCaseClause(clause, clause.expression, statements));
            }
            else {
                clauses.push(this.tsc.factory.updateDefaultClause(clause, statements));
            }
        }
        let caseBlock = this.tsc.factory.updateCaseBlock(node.caseBlock, clauses);
        return this.tsc.factory.updateSwitchStatement(node, node.expression, caseBlock);
    }
    instrumentLoop(func, node) {
        let region = this.getSourceRegion(node);
        if (!region) {
            return node;
        }
        let regionIdx = func.addRegion(region);
        let statement = node.statement;
        let stmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
        if (this.tsc.isBlock(node.statement)) {
            const statements = Array.from(node.statement.statements);
            statements.unshift(stmt);
            statement = this.tsc.factory.updateBlock(node.statement, statements);
        }
        else {
            const statements = [stmt, node.statement];
            statement = this.tsc.factory.createBlock(statements);
        }
        if (this.tsc.isWhileStatement(node)) {
            return this.tsc.factory.updateWhileStatement(node, node.expression, statement);
        }
        else if (this.tsc.isForStatement(node)) {
            return this.tsc.factory.updateForStatement(node, node.initializer, node.condition, node.incrementor, statement);
        }
        else if (this.tsc.isDoStatement(node)) {
            return this.tsc.factory.updateDoStatement(node, statement, node.expression);
        }
        else if (this.tsc.isForInStatement(node)) {
            return this.tsc.factory.updateForInStatement(node, node.initializer, node.expression, statement);
        }
        else if (this.tsc.isForOfStatement(node)) {
            return this.tsc.factory.updateForOfStatement(node, node.awaitModifier, node.initializer, node.expression, statement);
        }
        else {
            return node;
        }
    }
    instrumentTryStatement(func, node) {
        let tryBlock = node.tryBlock;
        let tryRegion = this.getSourceRegion(tryBlock);
        if (tryRegion) {
            let regionIdx = func.addRegion(tryRegion);
            let statements = Array.from(tryBlock.statements);
            let stmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
            statements.unshift(stmt);
            tryBlock = this.tsc.factory.updateBlock(tryBlock, statements);
        }
        let catchClause = node.catchClause;
        let catchRegion = this.getSourceRegion(catchClause);
        if (catchRegion && catchClause) {
            let regionIdx = func.addRegion(catchRegion);
            let statements = Array.from(catchClause.block.statements);
            let stmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
            statements.unshift(stmt);
            let block = this.tsc.factory.updateBlock(catchClause.block, statements);
            catchClause = this.tsc.factory.updateCatchClause(catchClause, catchClause.variableDeclaration, block);
        }
        let finallyBlock = node.finallyBlock;
        let finallyRegion = this.getSourceRegion(finallyBlock);
        if (finallyRegion && finallyBlock) {
            let regionIdx = func.addRegion(finallyRegion);
            let statements = Array.from(finallyBlock.statements);
            let stmt = func.createRegionInstrumentExpression(this.objName, regionIdx);
            statements.unshift(stmt);
            finallyBlock = this.tsc.factory.updateBlock(finallyBlock, statements);
        }
        return this.tsc.factory.updateTryStatement(node, tryBlock, catchClause, finallyBlock);
    }
    instrumentConditionalExpression(func, node) {
        let region = this.getSourceRegion(node);
        if (!region) {
            return node;
        }
        let branchIdx = func.addBranch(new coverage_1.Branch(region.startLoc, region.endLoc, node.ignored));
        let stmtTrue = func.createBranchInstrumentExpression(this.objName, branchIdx, true);
        let stmtFalse = func.createBranchInstrumentExpression(this.objName, branchIdx, false);
        let whenTrue = this.tsc.factory.createParenthesizedExpression(this.tsc.factory.createBinaryExpression(stmtTrue.expression, this.tsc.factory.createToken(ts.SyntaxKind.CommaToken), node.whenTrue));
        let whenFalse = this.tsc.factory.createParenthesizedExpression(this.tsc.factory.createBinaryExpression(stmtFalse.expression, this.tsc.factory.createToken(ts.SyntaxKind.CommaToken), node.whenFalse));
        return this.tsc.factory.updateConditionalExpression(node, node.condition, node.questionToken, whenTrue, node.colonToken, whenFalse);
    }
    /**
     * instrument coverage data to each ts file header
     * @param node ts.SourceFile
     */
    instrumentCoverageData(node) {
        let testMode = this.projectConfig.testMode === 'ohosTest' ? 'ohosTest' : 'test';
        let initCoveragePath = `${this.projectConfig.modulePath}/.test/default/intermediates/${testMode}/init_coverage.json`;
        if (this.hasInstrumentCollector) {
            node = helper_1.Helper.instrumentImportOhosFs(node);
        }
        if (this.hasInstrumentImportWant) {
            node = helper_1.Helper.instrumentImportWant(node);
        }
        if (this.coverageData.functions.length === 0) {
            return node;
        }
        this.formatInitCovData(initCoveragePath);
        this.coverageData.path = path.relative(this.coverageData.projectPath ? this.coverageData.projectPath : '', this.coverageData.path).replace(/\\/g, '/');
        this.coverageData.projectPath = '';
        node = helper_1.Helper.instrumentBjcCovCls(node, this.objName, this.coverageData);
        if (this.projectConfig.onProcessExit) {
            node = helper_1.Helper.instrumentProcessExitEvent(node);
        }
        return node;
    }
    formatInitCovData(initCoveragePath) {
        this.coverageData.path = this.coverageData.path.replace(/\\/g, '/');
        let covPath = this.coverageData.path;
        let coverageContent = JSON.stringify(this.coverageData);
        let formatSource = '';
        if (fs.existsSync(initCoveragePath)) {
            if (fs.statSync(initCoveragePath).size === 0) {
                formatSource = `${os.EOL}"${covPath}":${coverageContent}`;
            }
            else {
                formatSource = `,${os.EOL}"${covPath}":${coverageContent}`;
            }
        }
        else {
            fs.mkdirSync(path.dirname(initCoveragePath), { recursive: true });
            formatSource = `"${covPath}":${coverageContent}`;
        }
        fs.appendFileSync(initCoveragePath, formatSource);
    }
    parseFunction(node) {
        let name = this.buildMethodSignature(node);
        let region = this.getSourceRegion(node, true);
        if (!region) {
            return undefined;
        }
        if (region.startLoc.line === region.endLoc.line && region.startLoc.col === region.endLoc.col) {
            return undefined;
        }
        let func = new InstrumenterFunction(name, this.coverageData.functions.length, node.ignored);
        func.addRegion(region);
        this.coverageData.functions.push(func);
        return func;
    }
    instrumentFunctionEntry(func, node) {
        let body;
        let parent = node.parent;
        if (this.isInvalidEntryNodeBody(node)) {
            return node;
        }
        if (this.tsc.isBlock(node.body)) {
            const statements = Array.from(node.body.statements);
            statements.unshift(func.createFunctionInstrumentExpression(this.objName));
            body = this.tsc.factory.updateBlock(node.body, statements);
        }
        else {
            const statements = [this.tsc.factory.createReturnStatement(node.body)];
            statements.unshift(func.createFunctionInstrumentExpression(this.objName));
            body = this.tsc.factory.createBlock(statements);
        }
        if (this.tsc.isFunctionDeclaration(node)) {
            node = this.tsc.factory.updateFunctionDeclaration(node, this.tsc.getModifiers(node), node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, body);
        }
        else if (this.tsc.isMethodDeclaration(node)) {
            node = this.tsc.factory.updateMethodDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, body);
        }
        else if (this.tsc.isConstructorDeclaration(node)) {
            node = this.tsc.factory.updateConstructorDeclaration(node, this.tsc.getModifiers(node), node.parameters, body);
        }
        else if (this.tsc.isFunctionExpression(node)) {
            node = this.tsc.factory.updateFunctionExpression(node, this.tsc.getModifiers(node), node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, body);
        }
        else if (this.tsc.isGetAccessorDeclaration(node)) {
            node = this.tsc.factory.updateGetAccessorDeclaration(node, this.tsc.getModifiers(node), node.name, node.parameters, node.type, body);
        }
        else if (this.tsc.isSetAccessorDeclaration(node)) {
            node = this.tsc.factory.updateSetAccessorDeclaration(node, node.modifiers, node.name, node.parameters, body);
        }
        else if (this.tsc.isArrowFunction(node)) {
            node = this.tsc.factory.updateArrowFunction(node, node.modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, body);
        }
        node.parent = parent;
        return node;
    }
    isInvalidEntryNodeBody(node) {
        if (!node.body) {
            return true;
        }
        if (this.tsc.isArrowFunction(node) && this.tsc.isNewExpression(node.body)) {
            if (node.body && node.body.expression && this.tsc.isIdentifier(node.body.expression)) {
                let escapedText = node.body.expression.escapedText;
                if (this.getSourceFileName().includes(escapedText)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * ETS compilation will insert a new node, and there is no corresponding source code location
     * @param node
     * @param fuzz Whether to fuzz the location of the child node
     * @returns
     */
    getSourceRegion(node, fuzz = false) {
        if (!node) {
            return undefined;
        }
        let regionNodes = { posBak: node, endBak: node };
        if (node.pos < 0 && fuzz) {
            regionNodes = this.getRegionNodes(node);
        }
        if (!regionNodes.posBak || !regionNodes.endBak || regionNodes.endBak.pos < 0 || regionNodes.endBak.end < 0) {
            return undefined;
        }
        let start = this.tsc.getLineAndCharacterOfPosition(this.sourceFile, regionNodes.posBak.getStart(this.sourceFile));
        let end = this.tsc.getLineAndCharacterOfPosition(this.sourceFile, regionNodes.endBak.getEnd());
        return new coverage_1.Region(new coverage_1.Location(start.line + 1, start.character + 1), new coverage_1.Location(end.line + 1, end.character + 1), node.ignored);
    }
    getRegionNodes(node) {
        let posBak = undefined;
        let endBak = undefined;
        let visitor = (_node) => {
            if (_node.pos >= 0) {
                if (!posBak) {
                    posBak = _node;
                }
                endBak = _node;
                return _node;
            }
            return this.tsc.visitEachChild(_node, visitor, this.context);
        };
        this.tsc.visitEachChild(node, visitor, this.context);
        return { posBak, endBak };
    }
    /**
     * Instrument Ability cov collector
     * @param node
     */
    instrumentAbilityCovCollector(node) {
        var _a;
        const onCreateIdx = 0;
        const onDestroyIdx = 1;
        const onDumpIdx = 2;
        const CollectorFucIdx = 3;
        const CollectorPoints = new Set(['onCreate', 'onDestroy', 'onDump']);
        let members = Array.from(node.members);
        let ability = helper_1.Helper.buildAstFromTemplate(constants_1.Constants.TEMPLATE_ABILITY_COV_COLLECTOR)[1];
        members.push(ability.members[CollectorFucIdx]);
        let hasInstrumentMethods = new Set();
        // onCreate onDestroy onDump 
        for (let idx = 0; idx < members.length; idx++) {
            let member = members[idx];
            if (this.tsc.isMethodDeclaration(member) && this.tsc.isIdentifier(member.name) && CollectorPoints.has(member.name.text) && member.body) {
                hasInstrumentMethods.add(member.name.text);
                let statements = Array.from((_a = member.body) === null || _a === void 0 ? void 0 : _a.statements);
                /**
                 * insert follow statements to function onCreate
                 * let bjcEventhub = this.context.eventHub;
                 * bjcEventhub.on("coverage",() => {
                 *    this.__BJC_COV_CollectData();
                 * })
                 */
                this.setInstrumentation(member.name.text, statements);
                let body = this.tsc.factory.updateBlock(member.body, statements);
                members[idx] = this.tsc.factory.updateMethodDeclaration(member, member.modifiers, member.asteriskToken, member.name, member.questionToken, member.typeParameters, member.parameters, member.type, body);
                this.hasInstrumentCollector = true;
            }
        }
        // Instrument whole onCreate function in template
        if (!hasInstrumentMethods.has('onCreate')) {
            members.push(ability.members[onCreateIdx]);
            this.hasInstrumentCollector = true;
            this.hasInstrumentImportWant = true;
        }
        // Instrument whole onDestroy function in template
        if (!hasInstrumentMethods.has('onDestroy')) {
            members.push(ability.members[onDestroyIdx]);
            this.hasInstrumentCollector = true;
        }
        // Instrument whole onDump function in template
        if (!hasInstrumentMethods.has('onDump')) {
            members.push(ability.members[onDumpIdx]);
            this.hasInstrumentCollector = true;
        }
        return this.tsc.factory.updateClassDeclaration(node, node.modifiers, node.name, node.typeParameters, node.heritageClauses, members);
    }
    setInstrumentation(methodName, statements) {
        if (methodName === 'onCreate') {
            statements.unshift(...[
                this.tsc.factory.createVariableStatement(undefined, this.tsc.factory.createVariableDeclarationList([this.tsc.factory.createVariableDeclaration(this.tsc.factory.createIdentifier('bjcEventhub'), undefined, undefined, this.tsc.factory.createPropertyAccessExpression(this.tsc.factory.createPropertyAccessExpression(this.tsc.factory.createThis(), this.tsc.factory.createIdentifier('context')), this.tsc.factory.createIdentifier('eventHub')))], ts.NodeFlags.Let)),
                this.tsc.factory.createExpressionStatement(this.tsc.factory.createCallExpression(this.tsc.factory.createPropertyAccessExpression(this.tsc.factory.createIdentifier('bjcEventhub'), this.tsc.factory.createIdentifier('on')), undefined, [
                    this.tsc.factory.createStringLiteral('coverage'),
                    this.tsc.factory.createArrowFunction(undefined, undefined, [], undefined, this.tsc.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), this.tsc.factory.createBlock([this.tsc.factory.createExpressionStatement(this.tsc.factory.createCallExpression(this.tsc.factory.createPropertyAccessExpression(this.tsc.factory.createThis(), this.tsc.factory.createIdentifier('__BJC_COV_CollectData')), undefined, []))], true))
                ]))
            ]);
        }
        else {
            // insert this.__BJC_COV_CollectData() 
            statements.unshift(this.tsc.factory.createExpressionStatement(this.tsc.factory.createCallExpression(this.tsc.factory.createPropertyAccessExpression(this.tsc.factory.createThis(), this.tsc.factory.createIdentifier('__BJC_COV_CollectData')), undefined, [])));
        }
    }
}
exports.CoverageInstrumenter = CoverageInstrumenter;
