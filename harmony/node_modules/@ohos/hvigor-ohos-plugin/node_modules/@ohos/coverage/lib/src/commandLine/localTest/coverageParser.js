"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCppCoverageData = exports.parseCoverageData = exports.ENGINE_LOG_ERROR_MESSAGE_LOG = void 0;
const path = require("path");
const fs = require("fs");
const generateReportForHvigorw_1 = require("../../generateReportForHvigorw");
const child_process_1 = require("child_process");
const SourceMapParser_1 = require("../util/SourceMapParser");
const dataTag = 'OHOS_REPORT_COVERAGE_DATA: ';
const classTag = 'OHOS_REPORT_STATUS: class=';
const statusBaseTag = 'OHOS_REPORT_STATUS: ';
const stackTag = 'OHOS_REPORT_STATUS: stack=';
const streamTag = 'OHOS_REPORT_STATUS: stream=';
const testCaseTag = 'OHOS_REPORT_STATUS: test=';
const statusCodeTag = 'OHOS_REPORT_STATUS_CODE: ';
const resultTag = 'OHOS_REPORT_RESULT: stream=';
const OHOS_REPORT_COVERAGE_PATH = 'OHOS_REPORT_COVERAGE_PATH: ';
exports.ENGINE_LOG_ERROR_MESSAGE_LOG = '[Engine Log]Error message:';
const ohosTest = 'ohosTest';
const ohosTestInitPath = '.test/default/intermediates/ohosTest/init_coverage.json';
const unitTestInitPath = '.test/default/intermediates/test/init_coverage.json';
const localTestCoveragePath = '.test/default/intermediates/test/coverage_data/js_coverage.json';
const ENGINE_LOG_TAG = '[Engine Log]';
const ATOMIC_SERVICE = 'atomicService';
const NEW_SAND_BOX_PATH = './data/storage/el2/base/js_coverage.json';
const STACK_OVERFLOW = 'Stack overflow!';
const log4js = require('log4js');
const standardErrorMessage_1 = require('../../error/standardErrorMessage');
log4js.configure({
    appenders: {
        console: { type: 'console' },
    },
    categories: {
        default: { appenders: ['console'], level: 'all' },
    },
});
const consoleLogger = log4js.getLogger('console');
let className = '';
let testCaseName = '';
let isStackStatus = false;
let statusBaseIndex = -1;
let logFileArr = [];
let engineErrorStart = false;
let isLocalTest = true;
let isCoverage = true;
function dirOperate(coverageData, coverageDirectory, logger) {
    if (coverageData) {
        if (fs.existsSync(coverageDirectory)) {
            fs.unlinkSync(coverageDirectory);
        }
        fs.writeFileSync(coverageDirectory, coverageData, 'utf8');
        logger.debug('Coverage data from call back');
    }
    else {
        logger.debug('Coverage data from file');
    }
}
const parseCoverageData = async (coverageParserParam) => {
    const coverageType = coverageParserParam.isLocalTest ? 'test' : 'ohosTest';
    isLocalTest = coverageParserParam.isLocalTest;
    const logPath = `.test/default/intermediates/${coverageType}/coverage_data/coverage.log`;
    const coveragePath = `.test/default/intermediates/${coverageType}/coverage_data/js_coverage.json`;
    const testResultPath = `.test/default/intermediates/${coverageType}/coverage_data/test_result.txt`;
    const logger = coverageParserParam.logger;
    const modulePath = coverageParserParam.modulePath;
    const projectPath = coverageParserParam.projectPath;
    const logDirectory = path.join(modulePath, logPath);
    const coverageDirectory = path.join(modulePath, coveragePath);
    const testResultDirectory = path.join(modulePath, testResultPath);
    let dependenciesPaths = coverageParserParam.dependenciesPaths;
    isCoverage = coverageParserParam.coverage;
    const hdcPath = coverageParserParam.hdcPath;
    resetStatus();
    let splitSign = '';
    if (process.platform === 'win32') {
        splitSign = '\r\n';
    }
    else if (process.platform === 'darwin' || process.platform === 'linux') {
        splitSign = '\n';
    }
    const logFile = fs.readFileSync(logDirectory, 'utf-8');
    logFileArr = logFile.split(splitSign);
    if (fs.existsSync(testResultDirectory)) {
        fs.unlinkSync(testResultDirectory);
    }
    let coverageData = '';
    for await (const [idx, line] of logFileArr.entries()) {
        if (await isEngineError(line, logger, dependenciesPaths, modulePath)) {
            continue;
        }
        if (await logStack({ line, logger, filePath: testResultDirectory, idx, isCoverage, dependenciesPaths, modulePath }) ||
            logClassAndTestSuite(line, testResultDirectory) ||
            logTestResult(line, testResultDirectory)) {
            continue;
        }
        let dataIndex = line.indexOf(dataTag);
        if (dataIndex !== -1) {
            let data = line.substring(dataIndex + dataTag.length);
            coverageData = coverageData + data;
            continue;
        }
        if (coverageType === 'ohosTest' && line.indexOf(OHOS_REPORT_COVERAGE_PATH) !== -1) {
            coverageData = '';
            let coverageIndex = line.indexOf(OHOS_REPORT_COVERAGE_PATH);
            let pathInDevice = line.substring(coverageIndex + OHOS_REPORT_COVERAGE_PATH.length);
            let fileRecvArgs = ['file', 'recv', pathInDevice, coverageDirectory];
            if (isAtomicServiceProject(coverageParserParam.bundleType)) {
                fileRecvArgs = ['file', 'recv', '-b', coverageParserParam.bundleName, 'ls', NEW_SAND_BOX_PATH, coverageDirectory];
            }
            const fileRecvResult = (0, child_process_1.spawnSync)(hdcPath, fileRecvArgs, { encoding: 'utf-8', shell: true });
            logger.debug(`fileRecvResult: ${fileRecvResult}`);
            continue;
        }
    }
    dirOperate(coverageData, coverageDirectory, logger);
    await generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType, dependenciesPaths);
    await (0, exports.parseCppCoverageData)({
        modulePath: coverageParserParam.modulePath,
        projectPath: coverageParserParam.projectPath,
        hdcPath: coverageParserParam.hdcPath,
        coverage: coverageParserParam.coverage,
        logger: coverageParserParam.logger,
        isLocalTest: coverageParserParam.isLocalTest,
        dependenciesPaths: coverageParserParam.dependenciesPaths,
        bundleName: coverageParserParam.bundleName,
        bundleType: coverageParserParam.bundleType
    });
};
exports.parseCoverageData = parseCoverageData;
/**
 * parseCppCoverageData
 * 生成cpp覆盖率报告
 *
 * @param coverageParserParam
 */
const parseCppCoverageData = async (coverageParserParam) => {
    // 不是ohosTest 或 未开启覆盖率 都不执行后续逻辑
    if (coverageParserParam.isLocalTest || !coverageParserParam.coverage) {
        return;
    }
    const coveragePath = `/.test/default/intermediates/ohosTest/coverage_data/c++_coverage.profraw`;
    const coverageTransPath = `/.test/default/intermediates/ohosTest/coverage_data/c++_coverage.profdata`;
    const modulePath = coverageParserParam.modulePath;
    const coverageDirectory = path.join(modulePath, coveragePath);
    const hdcPath = coverageParserParam.hdcPath;
    const logger = coverageParserParam.logger;
    if (isAtomicServiceProject(coverageParserParam.bundleType)) {
        // 元服务不支持native开发方式 无需处理
        return;
    }
    // 2、hdc复制设备的覆盖率文件，失败则return -- hdc file recv xx
    let pathInDevice = 'data/app/el2/100/base/' + coverageParserParam.bundleName + '/c++_coverage.profraw';
    let recvCoverageFile = ['file', 'recv', pathInDevice, coverageDirectory];
    let deleteCoverageFile = ['shell', 'rm', pathInDevice];
    // 发送hdc指令获取/删除文件
    const resultRecvFile = (0, child_process_1.spawnSync)(hdcPath, recvCoverageFile, { encoding: 'utf-8', shell: true });
    logger.debug(`resultRecvFile: ${resultRecvFile}`);
    (0, child_process_1.spawnSync)(hdcPath, deleteCoverageFile, { encoding: 'utf-8', shell: true });
    if (resultRecvFile.stdout.indexOf('no such file or directory') !== -1) {
        // 文件不存在 说明没生成覆盖率文件
        return;
    }
    else if (resultRecvFile.stdout.indexOf('FileTransfer finish') === -1) {
        logger.warn(`Failed to retrieve the C++ test coverage file from device.`);
    }
    if (resultRecvFile.stderr) {
        logger.warn(resultRecvFile.stderr);
    }
    // 判断文件获取是否成功
    if (!fs.existsSync(coverageDirectory)) {
        logger.debug(`${coverageDirectory} not exist.`);
        return;
    }
    // 3、llvm转换报告格式，失败则return  -- 由profraw转换为.profdata文件
    let cppCoverageTransferPath = path.join(modulePath, coverageTransPath);
    let llvmPathBin = path.join(getSubstringUpTo(hdcPath, 'openharmony'), `/native/llvm/bin`);
    if (llvmPathBin.length === 0) {
        logger.warn(`Processing of the C++ test coverage file failed.`);
        return;
    }
    // llvm-profdata merge -sparse .\c++_coverage.profraw -o coverage.profdata
    let llvmProfdataPath = `"${llvmPathBin}/llvm-profdata"`;
    // 需要创建llvmProfdataPath在进行${}组装 否则在ide所在路径有空格的时候就会报错
    // 发送文件转换指令 c++_coverage.profraw -》 c++_coverage.profdat
    const llvmArgs = ['merge', '-sparse', coverageDirectory, '-o', cppCoverageTransferPath];
    const llvmResult = (0, child_process_1.spawnSync)(llvmProfdataPath, llvmArgs, { encoding: 'utf-8', shell: true });
    logger.debug(`llvmResult: ${llvmResult}`);
    if (llvmResult.stderr) {
        logger.warn(`Processing of the C++ test coverage file failed.`);
    }
    if (!fs.existsSync(cppCoverageTransferPath)) {
        logger.debug(`${cppCoverageTransferPath} not exist.`);
        return;
    }
    // 4、llvm转换报告为html，失败则return  --由.profdata转换为html文件
    /*
           * paramsGenerate组装成：
           * llvm-cov show libentry.so
           * -instr-profile=coverage.profdata
           * --show-line-counts-or-regions
           * --format=html
           * --output-dir=cpp_reports
           */
    let cppCoverageReportPath = `${modulePath}/.test/default/outputs/ohosTest/cpp_reports`;
    // ohosTestSoList 的类型是 string[]
    let ohosTestSoList = getOhosTestSoList(modulePath);
    if (ohosTestSoList.length === 0) {
        logger.warn(`Processing of the C++ test coverage file failed.`);
        return;
    }
    let ohosTestSoParams = ohosTestSoList
        .map(item => `-object ${item}`) // 注意 -object 在前面
        .join(' '); // 用空格分隔
    // 需要创建llvmCovPath在进行${}组装 否则在ide所在路径有空格的时候就会报错
    // 发送文件转换指令 c++_coverage.profraw -》 c++_coverage.profdat
    let llvmCovPath = `"${llvmPathBin}/llvm-cov"`;
    const cppReportArgs = ['show', ohosTestSoParams, `-instr-profile=${cppCoverageTransferPath}`,
        '--show-line-counts-or-regions', '--format=html', `--output-dir=${cppCoverageReportPath}`];
    const cppReportResult = (0, child_process_1.spawnSync)(llvmCovPath, cppReportArgs, { encoding: 'utf-8', shell: true });
    logger.debug(`cppReportResult: ${cppReportResult}`);
    if (cppReportResult.stderr) {
        logger.warn(`Generation of the C++ test coverage report failed.`);
    }
    if (!fs.existsSync(`${cppCoverageReportPath}/index.html`)) {
        logger.debug(`${cppCoverageReportPath}/index.html not exist.`);
        return;
    }
};
exports.parseCppCoverageData = parseCppCoverageData;
/**
 * getSubstringUpTo
 * 截取字符串中指定子字符串及之前的所有内容
 *
 * @param str 原始字符串
 * @param segment 要截取到的目标子字符串
 * @returns 截取后的字符串，如果未找到目标子字符串则返回原字符串
 */
function getSubstringUpTo(str, segment) {
    // 查找目标段落第一次出现的索引位置
    const index = str.indexOf(segment);
    if (index !== -1) {
        // 计算结束位置：索引位置 + 目标段落的长度
        const endIndex = index + segment.length;
        // 截取从开始到 endIndex 的子字符串 (substring 的 end 是不包含的)
        // 第一个字符是" 要去除掉
        return str.substring(1, endIndex);
    }
    else {
        // 如果找不到指定的段落，返回原字符串
        return '';
    }
}
/**
 * getOhosTestSoList
 *
 * @param modulePath
 */
function getOhosTestSoList(modulePath) {
    let ohosTestSoPath = `${modulePath}/build/default/intermediates/libs/ohosTest/`;
    try {
        // 读取模块路径下的所有项目
        const items = fs.readdirSync(ohosTestSoPath);
        // 过滤出第一个文件夹
        const firstDir = items.find(item => {
            const itemPath = path.join(ohosTestSoPath, item);
            return fs.statSync(itemPath).isDirectory();
        });
        // 如果没有找到文件夹，返回空数组
        if (!firstDir) {
            return [];
        }
        // 构造第一个文件夹的完整路径
        const firstDirPath = path.join(ohosTestSoPath, firstDir);
        // 读取该文件夹下的所有文件
        const files = fs.readdirSync(firstDirPath);
        // 过滤出以 .so 结尾的文件，并返回完整路径
        return files
            .filter(file => file.endsWith('.so'))
            .map(file => path.join(firstDirPath, file));
    }
    catch (error) {
        // 如果发生错误（如路径不存在、权限问题等），返回空数组
        return [];
    }
}
function isAtomicServiceProject(bundleType) {
    return ATOMIC_SERVICE === bundleType;
}
async function logStack(logStackParams) {
    const { line, logger, filePath, idx } = logStackParams;
    let tempStatusBaseIndex = line.indexOf(statusBaseTag);
    let hspDependencies = logStackParams.dependenciesPaths;
    let modulePath = logStackParams.modulePath;
    if (tempStatusBaseIndex !== -1) {
        isStackStatus = line.substring(tempStatusBaseIndex + statusBaseTag.length).startsWith('stack=');
        statusBaseIndex = tempStatusBaseIndex;
    }
    let stackIndex = line.indexOf(stackTag);
    if (stackIndex !== -1) {
        let streamLog = '';
        for (let i = idx; i < logFileArr.length; i++) {
            let streamIndex = logFileArr[i].indexOf(streamTag);
            if (streamIndex !== -1) {
                streamLog = logFileArr[i].substring(streamIndex + streamTag.length);
                break;
            }
        }
        let stackContent = line.substring(stackIndex + stackTag.length);
        let errInfo1 = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest, isCoverage });
        logger.error(streamLog);
        fs.appendFileSync(filePath, streamLog + '\n', 'utf8');
        if (errInfo1 !== '' && !streamLog.includes(STACK_OVERFLOW)) {
            logger.error(errInfo1);
            fs.appendFileSync(filePath, errInfo1 + '\n', 'utf8');
        }
        isStackStatus = true;
        return true;
    }
    if (isStackStatus) {
        let stackContent = line.substring(statusBaseIndex);
        let errInfo2 = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest, isCoverage });
        if (errInfo2 !== '') {
            logger.error(errInfo2);
        }
        fs.appendFileSync(filePath, errInfo2 + '\n', 'utf8');
        return true;
    }
    return false;
}
async function isEngineError(line, logger, hspDependencies, modulePath) {
    if (line.indexOf(exports.ENGINE_LOG_ERROR_MESSAGE_LOG) > -1) {
        engineErrorStart = true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) > -1) {
        let stackContent = line.substring(line.lastIndexOf(ENGINE_LOG_TAG) + ENGINE_LOG_TAG.length);
        let errInfo = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest: true, isCoverage: false });
        logger.error(errInfo);
        return true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) < 0) {
        engineErrorStart = false;
    }
    return false;
}
function logClassAndTestSuite(line, filePath) {
    let classIndex = line.indexOf(classTag);
    if (classIndex !== -1) {
        let tempClassName = line.substring(classIndex + classTag.length);
        if (tempClassName !== className) {
            className = tempClassName;
            fs.appendFileSync(filePath, `class=${className}\n`, 'utf8');
        }
        return true;
    }
    let testCaseIndex = line.indexOf(testCaseTag);
    if (testCaseIndex !== -1) {
        let tempTestCaseName = line.substring(testCaseIndex + testCaseTag.length);
        if (tempTestCaseName !== testCaseName) {
            testCaseName = tempTestCaseName;
            fs.appendFileSync(filePath, `test=${testCaseName}\n`, 'utf8');
        }
        return true;
    }
    return false;
}
function logTestResult(line, filePath) {
    let resultIndex = line.indexOf(resultTag);
    if (resultIndex !== -1) {
        let resultContent = line.substring(resultIndex + resultTag.length);
        fs.appendFileSync(filePath, resultContent + '\n', 'utf8');
        return true;
    }
    let statusCodeIndex = line.indexOf(statusCodeTag);
    if (statusCodeIndex !== -1) {
        let statusCode = Number.parseInt(line.substring(statusCodeIndex + statusCodeTag.length));
        switch (statusCode) {
            case 0:
                fs.appendFileSync(filePath, 'result=Success\n', 'utf8');
                break;
            case -1:
                fs.appendFileSync(filePath, 'result=Error\n', 'utf8');
                break;
            case -2:
                fs.appendFileSync(filePath, 'result=Failure\n', 'utf8');
                break;
            case -3:
                fs.appendFileSync(filePath, 'result=Ignore\n', 'utf8');
                break;
        }
        return true;
    }
    return false;
}
function resetStatus() {
    className = '';
    testCaseName = '';
    isStackStatus = false;
    statusBaseIndex = -1;
}
async function generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType, dependenciesPaths) {
    if (!isCoverage) {
        return;
    }
    let initCoveragePath = `${modulePath}/.test/default/intermediates/${coverageType}/init_coverage.json`;
    let jsCoveragePath = `${modulePath}/.test/default/intermediates/${coverageType}/coverage_data/js_coverage.json`;
    if (!fs.existsSync(initCoveragePath)) {
        consoleLogger.error((standardErrorMessage_1.getFormattedErrorMsg)('FILE_DOES_NOT_EXIST').replace('{path}', initCoveragePath));
        return;
    }
    for (let item of dependenciesPaths) {
        let hspModule = item.split('build\\default\\outputs')[0];
        if (hspModule === item) {
            hspModule = item.split('build/default/outputs')[0];
        }
        let hspInitCoveragePath;
        let hspJsCoveragePath;
        if (coverageType.includes(ohosTest)) {
            hspInitCoveragePath = path.join(hspModule, ohosTestInitPath);
            hspJsCoveragePath = '';
        }
        else {
            hspInitCoveragePath = path.join(hspModule, unitTestInitPath);
            hspJsCoveragePath = path.join(hspModule, localTestCoveragePath);
        }
        if (fs.existsSync(hspInitCoveragePath)) {
            initCoveragePath = initCoveragePath + '#' + hspInitCoveragePath;
        }
        if (fs.existsSync(hspJsCoveragePath)) {
            jsCoveragePath = jsCoveragePath + '#' + hspJsCoveragePath;
        }
    }
    const reportPath = `${modulePath}/.test/default/outputs/${coverageType}/reports`;
    let coverPath = fs.existsSync(coverageDirectory) ? `${jsCoveragePath}#${initCoveragePath}` : initCoveragePath;
    await (0, generateReportForHvigorw_1.generateReportForHvigorw)(projectPath, reportPath, coverPath);
}
