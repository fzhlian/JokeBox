"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCoverageOhosTest = void 0;
const path = require("path");
const fs = require("fs");
const crypto_1 = require("crypto");
const child_process_1 = require("child_process");
const coverageParser_1 = require("../localTest/coverageParser");
const standardErrorMessage_1 = require("../../error/standardErrorMessage");
const logRelativeDir = '.test/default/intermediates/ohosTest/coverage_data';
const logRelativePath = `${logRelativeDir}/coverage.log`;
const testNameRule = /^[A-Za-z]{1}[\w#,.]*$/;
const lineBreak = /[(\r\n)\r\n]+/;
const logGetNewAsanFile = 'getNewAsanFile';
const localTmpDir = '/data/local/tmp/';
const logCreateLocalTmpDir = 'createLocalTmpDir';
const logUninstallBundle = 'uninstallBundle';
const logRemoveTmpDir = 'removeTmpDir';
const tagFileTransfer = 'FileTransfer finish';
const tagInstallSuccessfull = 'install bundle successfully.';
const logInstallSuccessfull = 'Finished install haps';
async function bundleOperate(hdcPath, bundleName, hapsPath, logger) {
    await uninstallBundle(hdcPath, bundleName, logger);
    let randomPathInLocalTmp = await createLocalTmpDir(hdcPath, logger);
    await pushHaps(hdcPath, hapsPath, randomPathInLocalTmp, logger);
    await installHaps(hdcPath, randomPathInLocalTmp, logger);
    await removeTmpDir(hdcPath, randomPathInLocalTmp, logger);
    return true;
}
async function createLocalTmpDir(hdcPath, logger) {
    const uuid = (0, crypto_1.randomUUID)().replace(/-/g, '');
    let randomPathInLocalTmp = localTmpDir + uuid;
    const args = ['shell', 'mkdir', randomPathInLocalTmp];
    const result = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
    logger.debug(logCreateLocalTmpDir, result);
    if (result.stdout) {
        throw new Error(result.stdout);
    }
    if (result.stderr) {
        throw new Error(result.stderr);
    }
    return randomPathInLocalTmp;
}
async function removeTmpDir(hdcPath, targetDir, logger) {
    const args = ['shell', 'rm', '-rf', targetDir];
    const result = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
    logger.debug(logRemoveTmpDir, result);
    if (result.stderr) {
        throw new Error(result.stderr);
    }
}
async function pushHaps(hdcPath, hapsPath, targetDir, logger) {
    for (const hapPath of hapsPath) {
        if (!hapPath.endsWith('.hap') && !hapPath.endsWith('.hsp')) {
            continue;
        }
        if (!fs.existsSync(hapPath)) {
            await removeTmpDir(hdcPath, targetDir, logger);
            throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('PATH_DOES_NOT_EXIST').replace('{path}', hapPath));
        }
        logger.debug(hapPath);
        const args = ['file', 'send', hapPath, targetDir];
        const result = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
        logger.debug(result);
        if (result.stderr) {
            throw new Error(result.stderr);
        }
        if (result.stdout && result.stdout.startsWith(tagFileTransfer)) {
            continue;
        }
        else {
            await removeTmpDir(hdcPath, targetDir, logger);
            throw new Error(result.stdout);
        }
    }
}
async function uninstallBundle(hdcPath, bundleName, logger) {
    const args = ['uninstall', bundleName];
    const result = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
    logger.debug(logUninstallBundle, result);
}
async function installHaps(hdcPath, targetDir, logger) {
    const command = hdcPath;
    const args = ['shell', 'bm', 'install', '-p', targetDir];
    const result = (0, child_process_1.spawnSync)(command, args, { encoding: 'utf-8', shell: true });
    logger.debug(result);
    if (result.stderr) {
        throw new Error(result.stderr);
    }
    if (result.stdout && result.stdout.indexOf(tagInstallSuccessfull) !== -1) {
        logger.info(logInstallSuccessfull);
    }
    else {
        await removeTmpDir(hdcPath, targetDir, logger);
        throw new Error(result.stdout);
    }
}
function dirOperate(modulePath, bundleName) {
    const logAbsolutePath = path.join(modulePath, logRelativePath);
    if (fs.existsSync(logAbsolutePath)) {
        fs.unlinkSync(logAbsolutePath);
    }
    let logDirectory = path.dirname(logAbsolutePath);
    if (fs.existsSync(logDirectory)) {
        let files = fs.readdirSync(logDirectory);
        for (let fileItem of files) {
            if (fileItem.startsWith(`asan-${bundleName}-`)) {
                fs.unlinkSync(path.join(logDirectory, fileItem));
            }
        }
    }
    else {
        fs.mkdirSync(logDirectory, { recursive: true });
    }
    return logAbsolutePath;
}
async function getNewAsanFile(hdcPath, bundleName, oldAsanFiles, logger) {
    let result = new Array();
    const args = ['shell', 'hidumper', '-s', '1201', '-a', '"-p Faultlogger"'];
    const stdResult = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
    logger.debug(logGetNewAsanFile, stdResult);
    if (stdResult.stderr) {
        logger.error(stdResult.stderr);
        return result;
    }
    if (stdResult.stdout.includes('error: ')) {
        logger.error(stdResult.stdout);
        return result;
    }
    return stdResult.stdout.split(lineBreak)
        .filter(line => line.trim().startsWith(`asan-${bundleName}-`))
        .filter(file => !oldAsanFiles.includes(file));
}
async function dumpFaultlog(hdcPath, modulePath, asanFileName, logger) {
    let asanLogPath = `${modulePath}/${logRelativeDir}/${asanFileName}.log`;
    const args = ['shell', 'hidumper', '-s', '1201', '-a', `"-p Faultlogger -f ${asanFileName}"`, '>', asanLogPath];
    const stdResult = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
    logger.debug('Saving asan log...');
    if (stdResult.stderr) {
        logger.error(stdResult.stderr);
    }
    if (stdResult.stdout.includes('error: ')) {
        logger.error(stdResult.stdout);
    }
}
/**
 *
 * @param testInstrumentParam
 */
const executeCoverageOhosTest = async (testInstrumentParam) => {
    let { toolchainsPath, projectPath, modulePath, bundleName, bundleType, coverage, logger, scope, testModuleName, targetHapPath, testHapPath, dependenciesPaths } = testInstrumentParam;
    if (scope !== '' && !testNameRule.test(scope)) {
        throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('SCOPE_IS_INVALID').replace('{scope}', scope));
    }
    let hdcPath = toolchainsPath;
    try {
        if (process.platform === 'win32') {
            hdcPath = path.join(toolchainsPath, 'hdc.exe');
        }
        else if (process.platform === 'darwin' || process.platform === 'linux') {
            hdcPath = path.join(toolchainsPath, 'hdc');
        }
        hdcPath = `"${hdcPath}"`;
        dependenciesPaths.push(targetHapPath);
        dependenciesPaths.push(testHapPath);
        await bundleOperate(hdcPath, bundleName, dependenciesPaths, logger);
        let asanFileBeforeAATest = await getNewAsanFile(hdcPath, bundleName, new Array(), logger);
        const logAbsPath = dirOperate(modulePath, bundleName);
        let args = ['shell', 'aa', 'test', '-b', bundleName, '-m', testModuleName, '-s', 'unittest',
            '/ets/testrunner/OpenHarmonyTestRunner', '-s', 'timeout', '15000', '-s', 'coverage', `${coverage}`];
        if (scope) {
            args = ['shell', 'aa', 'test', '-b', bundleName, '-m', testModuleName, '-s', 'unittest',
                '/ets/testrunner/OpenHarmonyTestRunner', '-s', 'class', scope, '-s', 'timeout', '15000', '-s', 'coverage', `${coverage}`];
        }
        const { stdout, stderr } = (0, child_process_1.spawnSync)(hdcPath, args, { encoding: 'utf-8', shell: true });
        if (stdout.includes('ExecuteCommand need connect-key?')) {
            throw new Error('ExecuteCommand need connect-key?');
        }
        if (stdout.includes('error: unlock screen failed in developer mode') || stdout.includes('Error Code:10106102')) {
            throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('NO_TEST_RESULTS'));
        }
        if (stderr) {
            throw new Error(stderr);
        }
        fs.writeFileSync(logAbsPath, stdout, { flag: 'a+' });
        let asanFileAfterAATest = await getNewAsanFile(hdcPath, bundleName, asanFileBeforeAATest, logger);
        if (asanFileAfterAATest.length > 0) {
            await dumpFaultlog(hdcPath, modulePath, asanFileAfterAATest[0], logger);
        }
        await (0, coverageParser_1.parseCoverageData)({
            modulePath: modulePath,
            projectPath: projectPath,
            hdcPath: hdcPath,
            coverage: coverage,
            logger: logger,
            isLocalTest: false,
            dependenciesPaths: dependenciesPaths,
            bundleName: bundleName,
            bundleType: bundleType
        });
    }
    catch (error) {
        const err = error;
        if (err.message.includes('ExecuteCommand need connect-key?')) {
            throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('CONNECT_FAILED') + error);
        }
        else {
            throw new Error(error);
        }
    }
};
exports.executeCoverageOhosTest = executeCoverageOhosTest;
