"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.collectDuplicateHarInfos=exports.checkHasOnlyOneHap=exports.getHspNeedDeduplicateHarInfoMap=exports.getMergedHapAllHspDependencies=exports.getMergedHap=exports.processHarDeduplicate=void 0;const hvigor_1=require("@ohos/hvigor"),ohos_plugin_id_js_1=require("../plugin/common/ohos-plugin-id.js"),ohos_logger_js_1=require("../utils/log/ohos-logger.js"),_log=ohos_logger_js_1.OhosLogger.getLogger("HarDeduplicate");let _hspNeedDeduplicateHarMap,_mergedHap,_mergedHapAllHspLocalDependencies;function processHarDeduplicate(e){var n,t,o,a;(null===(o=null===(t=null===(n=e.getTaskService())||void 0===n?void 0:n.getBuildOption())||void 0===t?void 0:t.packOptions)||void 0===o?void 0:o.deduplicateHar)&&!(null===(a=e.getTaskService())||void 0===a?void 0:a.isFaMode())&&(checkHasOnlyOneHap(e),collectDuplicateHarInfos(e._project))}function getMergedHap(){return _mergedHap}function getMergedHapAllHspDependencies(){return _mergedHapAllHspLocalDependencies}function getHspNeedDeduplicateHarInfoMap(e){if(_hspNeedDeduplicateHarMap)return _hspNeedDeduplicateHarMap[e]}function checkHasOnlyOneHap(e){var n,t;const o=null===(n=e.getTaskService())||void 0===n?void 0:n.getTargetProduct().name,a=null===(t=e.getTaskService())||void 0===t?void 0:t.getProductDataMap();if(!o||!a)return;const s=[];for(const e of a.values())if(e.length>0){e[0].getModuleModel().isHapModule()&&s.push(e[0].getModuleModel().getName())}s.length>1&&_log.printErrorExit("HAR_DEDUPLICATE_SUPPORT_ONLY_ONE_HAP",[s.length,s.join(","),o])}function collectDuplicateHarInfos(e){const n={},t={},o={};let a,s;if(e.getAllSubModules().forEach(e=>{const d=e.getPluginById(ohos_plugin_id_js_1.OhosPluginId.OHOS_HAP_PLUGIN),c=e.getPluginById(ohos_plugin_id_js_1.OhosPluginId.OHOS_HSP_PLUGIN);if(d){const e=d.getModuleModel();e&&(a=e.getName(),s=e.getOhPackageJson5Path()),processHap(d,t,o,n)}else c&&processHsp(c,t,o,n)}),_log.debug(`entryHap ${a} oh-package.json5 ${s}`),!a||!s)return;_mergedHap=a;const d=hvigor_1.MetricFactory.createDurationEvent("collect duplicate hars","Collect duplicate hars",hvigor_1.HvigorTaskGroupType.SYNC_TASK_GROUP);d.start(),markNeedDeduplicateHar(a,s,_mergedHapAllHspLocalDependencies,t,o,n),d.stop()}function processHap(e,n,t,o){var a,s,d,c,i,l,p;const r=null===(a=e.getModuleModel())||void 0===a?void 0:a.getName(),g=null===(s=e.getTaskService())||void 0===s?void 0:s.getAllDependencies().filter(e=>!e.isHspDependency()),u=null===(d=e.getTaskService())||void 0===d?void 0:d.getAllDirectDependencies().filter(e=>!e.isHspDependency()),H=null===(c=e.getTaskService())||void 0===c?void 0:c.getHspModuleDependencyNames();g&&u&&H&&r&&(n[r]=new Set(g.map(e=>{const n=e.getDependencyRootPath();return o[n]=e,n})),t[r]=new Set(u.map(e=>e.getDependencyRootPath())),_mergedHapAllHspLocalDependencies=null!==(p=null===(l=null===(i=e.getTaskService())||void 0===i?void 0:i.getAllHspDependencies())||void 0===l?void 0:l.filter(e=>e.isLocal()).map(e=>{var n,t;return null!==(t=null===(n=e.getModuleJsonObj())||void 0===n?void 0:n.module.name)&&void 0!==t?t:""}))&&void 0!==p?p:[])}function processHsp(e,n,t,o){var a,s,d,c;const i=null===(a=e.getTaskService())||void 0===a?void 0:a.getAllDependencies().filter(e=>!e.isHspDependency()),l=null===(s=e.getTaskService())||void 0===s?void 0:s.getAllDirectDependencies().filter(e=>!e.isHspDependency()),p=null===(d=e.getTaskService())||void 0===d?void 0:d.getHspModuleDependencyNames(),r=null===(c=e.getModuleModel())||void 0===c?void 0:c.getName();i&&l&&p&&r&&(n[r]=new Set(i.map(e=>{const n=e.getDependencyRootPath();return o[n]=e,n})),t[r]=new Set(l.map(e=>e.getDependencyRootPath())))}function getIntersection(e,n){const[t,o]=e.size<=n.size?[e,n]:[n,e];return new Set([...t].filter(e=>o.has(e)))}function markNeedDeduplicateHar(e,n,t,o,a,s){const d=o[e],c=a[e],i={},l=new Set;for(let n=0;n<t.length;n++){const p=t[n];i[p]=new Set;const r=o[p],g=a[p];if(!r||!g)continue;getIntersection(d,r).forEach(n=>{g.has(n)&&!c.has(n)&&l.add(`${s[n].getPackageName()}: the common dependency of ${e} and ${p} must be declared in dependencies of ${e}`),i[p].add(n)})}for(let n=0;n<t.length;n++)for(let d=n+1;d<t.length;d++){const p=t[n],r=t[d],g=o[p],u=o[r],H=a[p],D=a[r];getIntersection(g,u).forEach(n=>{(H.has(n)||D.has(n))&&!c.has(n)&&l.add(`${s[n].getPackageName()}: the common dependency of ${p} and ${r} must be declared in dependencies of ${e}`),i[p].add(n),i[r].add(n)})}l.size>0&&_log.printErrorExit("HAR_DEDUPLICATE_DEPENDENCY_CHECK_ERROR",[[...l].join("\n")],[[e,n]]);const p={};Object.keys(i).forEach(e=>{p[e]={};i[e].forEach(n=>{p[e][n]=makeDependencyObject(s[n])})}),_log.debug("hspNeedDeduplicateHarMap",p),_hspNeedDeduplicateHarMap=p}function makeDependencyObject(e){return{packageName:e.getPackageName(),dependencyRootPath:e.getDependencyRootPath(),isModuleDependency:e.isModuleDependency(),isLocal:e.isLocal(),isByteCodeHarDependency:e.isByteCodeHarDependency(),isOtherDependency:e.isOtherDependency(),isSODependency:e.isSODependency(),isHspDependency:e.isHspDependency(),isHarDependency:e.isHarDependency()}}exports.processHarDeduplicate=processHarDeduplicate,exports.getMergedHap=getMergedHap,exports.getMergedHapAllHspDependencies=getMergedHapAllHspDependencies,exports.getHspNeedDeduplicateHarInfoMap=getHspNeedDeduplicateHarInfoMap,exports.checkHasOnlyOneHap=checkHasOnlyOneHap,exports.collectDuplicateHarInfos=collectDuplicateHarInfos;